# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P12T_MPPY_DouT9kTJKU8o-kBtEM-z6k
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid")

transition_matrix = np.array([[0.9, 0.1], [0.1, 0.9]])

def markov_step(current_position):
    return np.random.choice(np.arange(len(transition_matrix)), p=transition_matrix[current_position])

n = 500
x = np.zeros(n)
y = np.zeros(n)
k = 10

for i in range(1, n):
    x[i] = x[i - 1] + np.random.randn()
    y[i] = y[i - 1] + np.random.randn()

    if i % k == 0:
        x[i], y[i] = markov_step(0), markov_step(1)

fig, ax = plt.subplots(1, 1, figsize=(8, 8))
sns.lineplot(x=x, y=y, sort=False, marker='o', markersize=5, color='blue', ax=ax)


ax.plot(x[0], y[0], marker='o', markersize=10, color='green', label='Start')
ax.plot(x[-1], y[-1], marker='o', markersize=10, color='red', label='End')

ax.set_aspect('equal', 'box')
plt.title('Marche aléatoire dans le plan (x,y) avec Markov Chain')
plt.xlabel('position en x')
plt.ylabel('position en y')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.animation import FuncAnimation

# Set the Seaborn style
sns.set(style="whitegrid")

# Define Markov chain transition matrix
transition_matrix = np.array([[0.9, 0.1], [0.1, 0.9]])

def markov_step(current_position):
    return np.random.choice(np.arange(len(transition_matrix)), p=transition_matrix[current_position])

n = 500
x = np.zeros(n)
y = np.zeros(n)
k = 10

# Generate random walk with Markov chain transitions
for i in range(1, n):
    x[i] = x[i - 1] + np.random.randn()
    y[i] = y[i - 1] + np.random.randn()

    # Apply Markov chain transition for every k steps
    if i % k == 0:
        x[i], y[i] = markov_step(0), markov_step(1)

# Create a line plot using Seaborn to connect the points in the Markov chain
fig, ax = plt.subplots(1, 1, figsize=(8, 8))
line, = ax.plot(x, y, marker='o', markersize=5, color='blue')

# Highlight the starting and ending points
start_marker, = ax.plot(x[0], y[0], marker='o', markersize=10, color='green', label='Start')
end_marker, = ax.plot(x[-1], y[-1], marker='o', markersize=10, color='red', label='End')

ax.set_aspect('equal', 'box')  # Make sure the aspect ratio is equal

# Set plot title and labels
plt.title('Marche aléatoire dans le plan (x,y) avec Markov Chain')
plt.xlabel('position en x')
plt.ylabel('position en y')

# Show the legend
plt.legend()

def update(frame):
    line.set_data(x[:frame], y[:frame])
    start_marker.set_data(x[frame], y[frame])
    end_marker.set_data(x[-1], y[-1])

# Create animation
animation = FuncAnimation(fig, update, frames=len(x), interval=50, repeat=False)

# Show the animation
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set the Seaborn style
sns.set(style="whitegrid")

# Parameters
population_size = 1000
initial_infected = 1

# Initial state: 0=Susceptible, 1=Infected, 2=Recovered
initial_state = np.zeros(population_size)
initial_state[:initial_infected] = 1

# Define random factors for each individual
economic_activity = np.random.rand(population_size)  # Random economic activity between 0 and 1
region_factor = np.random.rand(population_size)  # Random region factor between 0 and 1

# Randomly assign individuals to different regions (for simplicity, let's assume two regions)
regions = np.random.choice([0, 1], size=population_size)

# Define parameters based on random factors
transmission_rate_base = 0.3
recovery_rate_base = 0.1

transmission_rate = transmission_rate_base + 0.2 * economic_activity
recovery_rate = recovery_rate_base + 0.1 * region_factor

# Simulation
n_days = 100
sir_states = np.zeros((n_days, population_size), dtype=int)
sir_states[0, :] = initial_state

for day in range(1, n_days):
    # Update states based on SIR model with additional random factors
    for person in range(population_size):
        if sir_states[day - 1, person] == 0:  # Susceptible
            # Calculate probability of infection based on transmission rate and region factor
            infection_prob = transmission_rate[person] * (1 + 0.5 * regions[person])
            if np.random.rand() < infection_prob:
                sir_states[day, person] = 1  # Infected
        elif sir_states[day - 1, person] == 1:  # Infected
            # Calculate probability of recovery based on recovery rate and economic activity
            recovery_prob = recovery_rate[person] * (1 - 0.3 * economic_activity[person])
            if np.random.rand() < recovery_prob:
                sir_states[day, person] = 2  # Recovered

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))

# Count occurrences of each state for each day
susceptible_counts = [np.sum(sir_states[day, :] == 0) for day in range(n_days)]
infected_counts = [np.sum(sir_states[day, :] == 1) for day in range(n_days)]
recovered_counts = [np.sum(sir_states[day, :] == 2) for day in range(n_days)]

# Plotting the evolution of S, I, R
ax.plot(range(n_days), susceptible_counts, label='Susceptible', color='blue')
ax.plot(range(n_days), infected_counts, label='Infected', color='orange')
ax.plot(range(n_days), recovered_counts, label='Recovered', color='green')

# Set plot title and labels
ax.set_title('Enhanced SIR Model with Random Factors - Evolution Over Time')
ax.set_xlabel('Days')
ax.set_ylabel('Count')
ax.legend()

# Show the plot
plt.show()